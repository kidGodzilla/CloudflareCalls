<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1,user-scalable=yes,minimal-ui,viewport-fit=cover">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">

    <title>Cloudflare Calls SFU Demo</title>

    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #videos {
            display: flex;
            flex-wrap: wrap;
        }
        video, audio {
            width: 300px;
            height: 225px;
            background-color: black;
            margin: 5px;
            border: 1px solid #ccc;
        }
        #controls {
            margin-top: 10px;
        }
        #controls button, #controls select {
            margin-right: 5px;
            padding: 10px 15px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        #dataChannelMessages {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
        }
    </style>
</head>
<body>
<h1>
    Cloudflare Calls SFU Demo
    (<a href="/docs/">Docs</a> | <a href="https://github.com/kidGodzilla/CloudflareCalls">GitHub</a>)
</h1>

<div id="videos">
    <!-- Local preview video -->
    <video id="localVideo" autoplay muted playsinline></video>
</div>

<div id="controls">
    <button id="acquireToken">Acquire Token</button>
    <button id="createRoom">Create Room</button>
    <button id="joinRoom">Join Room</button>
    <button id="leaveRoom">Leave Room</button>
    <button id="toggleVideo">Disable Video</button>
    <button id="toggleAudio">Disable Audio</button>
    <button id="shareScreen">Share Screen</button>
    <button id="unpublishAll">Unpublish All Tracks</button>

    <select id="audioInputSelect"></select>
    <select id="videoInputSelect"></select>
    <select id="audioOutputSelect"></select>

    <button id="previewMedia">Preview Media</button>

    <button id="sendData">Send Data</button>
</div>

<div id="dataChannelMessages">
    <h3>Data Channel Messages</h3>
</div>

<!-- Adapter.js for broader WebRTC compatibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/8.1.2/adapter.min.js"></script>

<!-- IMPORTANT: adjust the path to your refactored CloudflareCalls library -->
<script type="module">
    import CloudflareCalls from './CloudflareCalls.js';

    const calls = new CloudflareCalls();
    window.calls = calls; // for debugging

    const localVideo = document.getElementById('localVideo');
    const videosContainer = document.getElementById('videos');
    const acquireTokenBtn = document.getElementById('acquireToken');
    const createRoomBtn = document.getElementById('createRoom');
    const joinRoomBtn = document.getElementById('joinRoom');
    const leaveRoomBtn = document.getElementById('leaveRoom');
    const toggleVideoBtn = document.getElementById('toggleVideo');
    const toggleAudioBtn = document.getElementById('toggleAudio');
    const shareScreenBtn = document.getElementById('shareScreen');
    const dataChannelMessages = document.getElementById('dataChannelMessages');
    const sendDataBtn = document.getElementById('sendData');

    const audioInputSelect = document.getElementById('audioInputSelect');
    const videoInputSelect = document.getElementById('videoInputSelect');
    const audioOutputSelect = document.getElementById('audioOutputSelect');
    const previewMediaBtn = document.getElementById('previewMedia');

    // ===== 1) Populate device lists =====
    async function populateDeviceLists() {
        const devices = await calls.getAvailableDevices();
        // Populate audio/video input & audio output selects
        devices.audioInput.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Microphone ${audioInputSelect.length + 1}`;
            audioInputSelect.appendChild(option);
        });
        devices.videoInput.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${videoInputSelect.length + 1}`;
            videoInputSelect.appendChild(option);
        });
        devices.audioOutput.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Speaker ${audioOutputSelect.length + 1}`;
            audioOutputSelect.appendChild(option);
        });
    }
    populateDeviceLists();

    // ===== 2) Listen for device selection changes =====
    audioInputSelect.addEventListener('change', async () => {
        await calls.selectAudioInputDevice(audioInputSelect.value);
    });
    videoInputSelect.addEventListener('change', async () => {
        await calls.selectVideoInputDevice(videoInputSelect.value);
    });
    audioOutputSelect.addEventListener('change', async () => {
        await calls.selectAudioOutputDevice(audioOutputSelect.value);
    });

    // ===== 3) Preview Media =====
    previewMediaBtn.addEventListener('click', async () => {
        try {
            const previewStream = await calls.previewMedia({
                audioDeviceId: audioInputSelect.value,
                videoDeviceId: videoInputSelect.value
            }, localVideo);
            console.log('Preview successful.');
        } catch (err) {
            alert('Error previewing media: ' + err.message);
        }
    });

    // ===== 4) Remote Track Handling =====
    calls.onRemoteTrack(track => {
        console.log('New remote track:', { 
            sessionId: track.sessionId, 
            trackId: track.id,
            trackName: track.trackName,
            kind: track.kind 
        });
        
        // Find or create participant container
        let participantContainer = document.querySelector(`[data-participant-id="${track.sessionId}"]`);
        if (!participantContainer) {
            participantContainer = document.createElement('div');
            participantContainer.setAttribute('data-participant-id', track.sessionId);
            videosContainer.appendChild(participantContainer);
        }

        const mediaElement = track.kind === 'video' 
            ? document.createElement('video')
            : document.createElement('audio');

        mediaElement.autoplay = true;
        mediaElement.playsInline = true;
        if (track.kind === 'audio') mediaElement.controls = true;
        
        mediaElement.setAttribute('data-session-id', track.sessionId);
        mediaElement.setAttribute('data-track-id', track.id); // WebRTC track ID
        mediaElement.setAttribute('data-track-name', track.trackName); // Application track name
        mediaElement.setAttribute('data-mid', track.mid);
        
        mediaElement.srcObject = new MediaStream([track]);
        participantContainer.appendChild(mediaElement);
    });

    // ===== 4b) Handle Track Unpublished Events =====
    calls.onRemoteTrackUnpublished((sessionId, trackName) => {
        console.log('Track unpublished:', { sessionId, trackName });
        
        // First try exact match with track ID
        let mediaElement = document.querySelector(`[data-session-id="${sessionId}"][data-track-name="${trackName}"]`);
        
        if (!mediaElement) {
            console.warn('Could not find media element to remove:', { sessionId, trackName });
            return;
        }

        console.log('Found and removing track element:', mediaElement);
        if (mediaElement.srcObject) {
            mediaElement.srcObject.getTracks().forEach(track => track.stop());
        }
        mediaElement.remove();
        
        // Check if participant container is empty
        const participantContainer = document.querySelector(`[data-participant-id="${sessionId}"]`);
        if (participantContainer && !participantContainer.querySelector('video, audio')) {
            console.log('Removing empty participant container:', sessionId);
            participantContainer.remove();
        }
    });

    // ===== 5) Data Channel Callbacks =====
    calls.onDataMessage((msg) => {
        console.log('onDataMessage', msg);
        const p = document.createElement('p');
        p.textContent = 'Data Channel Received: ' + JSON.stringify(msg);
        dataChannelMessages.appendChild(p);
    });

    // calls.onDataMessageToParticipant((msg) => {
    //     // If your libraryâ€™s logic calls this for per-participant messages:
    //     console.log('onDataMessageToParticipant', msg);
    //     if (msg.to === calls.userId) {
    //         const p = document.createElement('p');
    //         p.textContent = 'Private Message Received: ' + JSON.stringify(msg);
    //         dataChannelMessages.appendChild(p);
    //     }
    // });

    // ===== 6) Participants =====
    calls.onParticipantJoined(async (participant) => {
        console.log('Participant joined:', participant);
        // Create a container for this participant if it doesn't exist
        let participantContainer = document.querySelector(`[data-participant-id="${participant.sessionId}"]`);
        if (!participantContainer) {
            participantContainer = document.createElement('div');
            participantContainer.setAttribute('data-participant-id', participant.sessionId);
            videosContainer.appendChild(participantContainer);
        }

        // We can auto-subscribe to that participant's "chat" data channel here:
        try {
            await calls.subscribeDataChannel(participant.sessionId, 'chat');
            console.log('Subscribed to participant\'s "chat" channel:', participant.sessionId);
        } catch (err) {
            console.warn('Error subscribing to participant chat channel:', err);
        }
    });

    calls.onParticipantLeft((sessionId) => {
        const participantContainer = document.querySelector(`[data-participant-id="${sessionId}"]`);
        if (participantContainer) {
            // Clean up any media elements
            const mediaElements = participantContainer.querySelectorAll('video, audio');
            mediaElements.forEach(element => {
                element.srcObject = null;
            });
            participantContainer.remove();
            console.log('Removed participant container:', sessionId);
        }
    });

    // ===== 7) Button handlers =====
    acquireTokenBtn.addEventListener('click', async () => {
        window._username = prompt('Enter your username:');

        const response = await fetch('/auth/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username: _username }),
        });
        const { token } = await response.json();
        calls.setToken(token);

        alert('Token acquired and stored.');
    });

    createRoomBtn.addEventListener('click', async () => {
        window._roomId = await calls.createRoom();
        history.replaceState(null, '', `?room_id=${encodeURIComponent(_roomId)}`);
        alert('Created room with ID: ' + _roomId);
    });

    joinRoomBtn.addEventListener('click', async () => {
        let searchRoomId = (location.search.split('room_id=')[1]).split('&')[0];
        if (!window._roomId && searchRoomId) window._roomId = searchRoomId;

        if (!window._roomId) window._roomId = prompt('Enter Room ID to join:');
        if (!_roomId) return;

        if (!window._username) window._username = prompt('Enter your username:');

        previewMediaBtn.click();

        try {
            await calls.joinRoom(_roomId, { username: _username });
            console.log('Joined room:', _roomId);

            history.replaceState(null, '', `?room_id=${encodeURIComponent(_roomId)}`);

            alert('Successfully joined room: ' + _roomId);

            // (Optional) publish a "chat" data channel for others to subscribe
            // await calls.publishDataChannel('chat');
            console.log('Published local "chat" data channel.');
        } catch (err) {
            console.error('Error joining room:', err);
            alert('Error joining room: ' + err.message);
        }
    });

    leaveRoomBtn.addEventListener('click', async () => {
        await calls.leaveRoom();
        alert('Left the room.');

        // Clean up remote media
        document.querySelectorAll('#videos video:not(#localVideo), #videos audio')
            .forEach(media => media.remove());
    });

    toggleVideoBtn.addEventListener('click', () => {
        const videoTrack = localVideo.srcObject?.getVideoTracks()[0];
        if (videoTrack) {
            const isEnabled = videoTrack.enabled;
            videoTrack.enabled = !isEnabled;
            calls.toggleMedia({ video: !isEnabled, audio: null });
            toggleVideoBtn.textContent = isEnabled ? 'Enable Video' : 'Disable Video';
        }
    });

    toggleAudioBtn.addEventListener('click', () => {
        const audioTrack = localVideo.srcObject?.getAudioTracks()[0];
        if (audioTrack) {
            const isEnabled = audioTrack.enabled;
            audioTrack.enabled = !isEnabled;
            calls.toggleMedia({ audio: !isEnabled, video: null });
            toggleAudioBtn.textContent = isEnabled ? 'Enable Audio' : 'Disable Audio';
        }
    });

    shareScreenBtn.addEventListener('click', async () => {
        try {
            await calls.shareScreen();
            alert('Screen sharing started.');
        } catch (err) {
            alert('Error sharing screen: ' + err.message);
        }
    });

    // ===== 8) Sending Data =====
    sendDataBtn.addEventListener('click', async () => {
        const content = prompt('Enter message:');
        if (!content) return;

        // We'll send everything on our "chat" channel
        // Make sure we've published it already (see joinRoom code above).
        // Then we can do:
        const message = { content, fromUser: calls.userId };

        calls.sendDataToAll(message);
    });

    document.getElementById('unpublishAll').addEventListener('click', async () => {
        await calls.unpublishAllTracks();
        alert('Unpublished all tracks');
    });
</script>
</body>
</html>
