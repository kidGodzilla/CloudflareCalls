<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1,user-scalable=yes,minimal-ui,viewport-fit=cover">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">

    <title>Cloudflare Calls SFU Demo</title>

    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #videos {
            display: flex;
            flex-wrap: wrap;
        }
        #videos audio {
            /* Comment out to show audio and see how things work or debug */
            display: none;
        }
        video, audio {
            width: 300px;
            height: 225px;
            background-color: black;
            /* margin: 5px; */
            border: 1px solid #ccc;
            object-fit: scale-down; /* Scale down for the demo, you would want the default behavior */
        }
        .participant-container {
            width: 300px;
            height: 225px;
            position: relative;
            margin: 5px;
        }
        #controls {
            margin-top: 10px;
        }
        #controls button, #controls select {
            margin-right: 5px;
            padding: 10px 15px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        #dataChannelMessages {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
        }
        #participants {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
        }
        .participant {
            padding: 8px;
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f5f5f5;
        }
        .participant button {
            padding: 4px 8px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .participant-container {
            position: relative;
            margin: 5px;
        }
        
        .participant-name {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1;
        }
        
        /* Update video styles */
        video {
            width: 300px;
            height: 225px;
            background-color: black;
            border: 1px solid #ccc;
            display: block; /* Ensures proper positioning of overlay */
        }

        /* Rooms box */
        #rooms {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
        }

        .room-item {
            padding: 8px;
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f5f5f5;
        }

        .room-info {
            flex-grow: 1;
            margin-right: 10px;
        }

        .room-name {
            font-weight: bold;
        }

        .room-metadata {
            font-size: 0.9em;
            color: #666;
        }

        .room-actions {
            display: flex;
            gap: 5px;
        }

        /* Add CSS for health indicators */
        .stream-health-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #666;
            z-index: 2;
        }

        .stream-health-good {
            background-color: #4CAF50;
        }

        .stream-health-fair {
            background-color: #FFA726;
        }

        .stream-health-poor {
            background-color: #F44336;
        }
    </style>
</head>
<body>
<h1>
    Cloudflare Calls SFU Demo
    (<a href="/docs/">Docs</a> | <a href="https://github.com/kidGodzilla/CloudflareCalls">GitHub</a>)
</h1>

<div id="videos">
    <!-- Local preview container -->
    <div class="participant-container" data-local="true">
        <video id="localVideo" autoplay muted playsinline></video>
        <div class="stream-health-indicator"></div>
        <div class="participant-name"></div>
    </div>
</div>

<div id="controls">
    <button id="acquireToken">Acquire Token</button>
    <button id="createRoom">Create Room</button>
    <button id="joinRoom">Join Room</button>
    <button id="leaveRoom">Leave Room</button>
    <button id="toggleVideo">Disable Video</button>
    <button id="toggleAudio">Disable Audio</button>
    <button id="shareScreen">Share Screen</button>
    <button id="unpublishAll">Unpublish All Tracks</button>
    <button id="getSessionState">Get Session State</button>
    <button id="forceUnpublish">Force Unpublish Video</button>

    <select id="audioInputSelect"></select>
    <select id="videoInputSelect"></select>
    <select id="audioOutputSelect"></select>

    <select onchange="setQuality(this.value)" style="padding: 8px; margin: 5px;">
        <optgroup label="16:9 High Quality">
            <option value="high_16x9_xl">16:9 High XL (1080p/30fps)</option>
            <option value="high_16x9_lg">16:9 High LG (720p/30fps)</option>
            <option value="high_16x9_md">16:9 High MD (480p/30fps)</option>
            <option value="high_16x9_sm">16:9 High SM (360p/30fps)</option>
            <option value="high_16x9_xs">16:9 High XS (270p/30fps)</option>
        </optgroup>
        <optgroup label="16:9 Medium Quality">
            <option value="medium_16x9_xl">16:9 Medium XL (1080p/24fps)</option>
            <option value="medium_16x9_lg">16:9 Medium LG (720p/24fps)</option>
            <option value="medium_16x9_md">16:9 Medium MD (480p/24fps)</option>
            <option value="medium_16x9_sm">16:9 Medium SM (360p/20fps)</option>
            <option value="medium_16x9_xs">16:9 Medium XS (270p/20fps)</option>
        </optgroup>
        <optgroup label="16:9 Low Quality">
            <option value="low_16x9_xl">16:9 Low XL (1080p/15fps)</option>
            <option value="low_16x9_lg">16:9 Low LG (720p/15fps)</option>
            <option value="low_16x9_md">16:9 Low MD (480p/15fps)</option>
            <option value="low_16x9_sm">16:9 Low SM (360p/12fps)</option>
            <option value="low_16x9_xs">16:9 Low XS (270p/10fps)</option>
        </optgroup>
        <optgroup label="4:3 High Quality">
            <option value="high_4x3_xl">4:3 High XL (960x720/30fps)</option>
            <option value="high_4x3_lg">4:3 High LG (640x480/30fps)</option>
            <option value="high_4x3_md">4:3 High MD (480x360/30fps)</option>
            <option value="high_4x3_sm">4:3 High SM (320x240/30fps)</option>
            <option value="high_4x3_xs">4:3 High XS (240x180/30fps)</option>
        </optgroup>
        <optgroup label="4:3 Medium Quality">
            <option value="medium_4x3_xl">4:3 Medium XL (960x720/24fps)</option>
            <option value="medium_4x3_lg">4:3 Medium LG (640x480/24fps)</option>
            <option value="medium_4x3_md">4:3 Medium MD (480x360/20fps)</option>
            <option value="medium_4x3_sm" selected>4:3 Medium SM (320x240/20fps)</option>
            <option value="medium_4x3_xs">4:3 Medium XS (240x180/20fps)</option>
        </optgroup>
        <optgroup label="4:3 Low Quality">
            <option value="low_4x3_xl">4:3 Low XL (960x720/15fps)</option>
            <option value="low_4x3_lg">4:3 Low LG (640x480/15fps)</option>
            <option value="low_4x3_md">4:3 Low MD (480x360/12fps)</option>
            <option value="low_4x3_sm">4:3 Low SM (320x240/10fps)</option>
            <option value="low_4x3_xs">4:3 Low XS (240x180/10fps)</option>
        </optgroup>
    </select>

    <button id="previewMedia">Preview Media</button>

    <button id="sendData">Send Data</button>

    <div id="trackStatus"></div>
</div>

<div id="rooms">
    <h3>Available Rooms</h3>
    <div id="roomList"></div>
</div>

<div id="participants">
    <h3>Participants</h3>
    <div id="participantList"></div>
</div>

<div id="dataChannelMessages">
    <h3>Data Channel Messages</h3>
</div>

<div id="connectionStatus" style="position: fixed; top: 10px; right: 10px;"></div>

<div id="connectionStats" style="position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 8px; font-family: monospace;">
    <h4 style="margin: 0 0 0 0;  cursor: pointer;" onclick="document.querySelector('.stats-grid').style.display === 'grid' ? document.querySelector('.stats-grid').style.display = 'none' : document.querySelector('.stats-grid').style.display = 'grid'">
        Connection Health
    </h4>
    <div class="stats-grid" style="display: none; grid-template-columns: auto auto; gap: 8px; font-size: 12px; margin-top: 10px;">
        <div>Upload:</div>
        <div id="uploadHealth">-</div>
        
        <div>Download:</div>
        <div id="downloadHealth">-</div>
        
        <div>Bitrate:</div>
        <div id="bitrateStats">-</div>
        
        <div>Quality:</div>
        <div id="qualityLimitation">-</div>
        
        <div>Packet Loss:</div>
        <div id="packetLoss">-</div>
        
        <div>Round Trip:</div>
        <div id="roundTrip">-</div>
    </div>
</div>

<!-- Adapter.js for broader WebRTC compatibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/8.1.2/adapter.min.js"></script>

<!-- IMPORTANT: adjust the path to your refactored CloudflareCalls library -->
<script type="module">
    import CloudflareCalls from './CloudflareCalls.js';

    const calls = new CloudflareCalls();
    window.calls = calls; // for debugging

    const localVideo = document.getElementById('localVideo');
    const videosContainer = document.getElementById('videos');
    const acquireTokenBtn = document.getElementById('acquireToken');
    const createRoomBtn = document.getElementById('createRoom');
    const joinRoomBtn = document.getElementById('joinRoom');
    const leaveRoomBtn = document.getElementById('leaveRoom');
    const toggleVideoBtn = document.getElementById('toggleVideo');
    const toggleAudioBtn = document.getElementById('toggleAudio');
    const shareScreenBtn = document.getElementById('shareScreen');
    const dataChannelMessages = document.getElementById('dataChannelMessages');
    const sendDataBtn = document.getElementById('sendData');

    const audioInputSelect = document.getElementById('audioInputSelect');
    const videoInputSelect = document.getElementById('videoInputSelect');
    const audioOutputSelect = document.getElementById('audioOutputSelect');
    const previewMediaBtn = document.getElementById('previewMedia');

    const getSessionStateBtn = document.getElementById('getSessionState');
    const forceUnpublishBtn = document.getElementById('forceUnpublish');
    const trackStatusDiv = document.getElementById('trackStatus');

    const participantList = document.getElementById('participantList');

    // ===== 1) Populate device lists =====
    async function populateDeviceLists() {
        const devices = await calls.getAvailableDevices();
        // Populate audio/video input & audio output selects
        devices.audioInput.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Microphone ${audioInputSelect.length + 1}`;
            audioInputSelect.appendChild(option);
        });
        devices.videoInput.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${videoInputSelect.length + 1}`;
            videoInputSelect.appendChild(option);
        });
        devices.audioOutput.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Speaker ${audioOutputSelect.length + 1}`;
            audioOutputSelect.appendChild(option);
        });
    }
    populateDeviceLists();

    // ===== 2) Listen for device selection changes =====
    audioInputSelect.addEventListener('change', async () => {
        await calls.selectAudioInputDevice(audioInputSelect.value);
    });
    videoInputSelect.addEventListener('change', async () => {
        await calls.selectVideoInputDevice(videoInputSelect.value);
    });
    audioOutputSelect.addEventListener('change', async () => {
        await calls.selectAudioOutputDevice(audioOutputSelect.value);
    });

    // ===== 3) Preview Media =====
    previewMediaBtn.addEventListener('click', async () => {
        try {
            const previewStream = await calls.previewMedia({
                audioDeviceId: audioInputSelect.value,
                videoDeviceId: videoInputSelect.value
            }, localVideo);
            console.log('Preview successful.');
        } catch (err) {
            alert('Error previewing media: ' + err.message);
        }
    });

    // ===== 4) Remote Track Handling =====
    calls.onRemoteTrack(async track => {
        console.log('New remote track:', track);
        
        // Skip if track is invalid or missing required properties
        if (!track.id || !track.trackName || !track.kind) {
            console.log('Skipping invalid track:', track);
            return;
        }
        
        // Update participant list when tracks change
        updateParticipantList();
        
        // Find participant info from the room
        const participants = await calls.listParticipants();
        console.log('Participants:', participants);
        
        const participant = participants.find(p => p.sessionId === track.sessionId);
        console.log('Found participant:', participant);
        
        if (!participant) {
            console.warn('Could not find participant info for session:', track.sessionId);
            return;
        }

        // Check if this is our own session ID
        const localContainer = document.querySelector('.participant-container[data-local="true"]');
        if (localContainer?.getAttribute('data-participant-id') === track.sessionId) {
            console.log('Skipping container creation for own session');
            return;
        }
        
        // Get user info for the participant
        const userInfo = await calls.getUserInfo(participant.userId);
        console.log('User info:', userInfo);
        
        // Create or find container
        let participantContainer = document.querySelector(`[data-participant-id="${track.sessionId}"]`);
        if (!participantContainer) {
            participantContainer = document.createElement('div');
            participantContainer.className = 'participant-container';
            participantContainer.setAttribute('data-participant-id', track.sessionId);
            videosContainer.appendChild(participantContainer);
            
            // Add health indicator
            const healthIndicator = document.createElement('div');
            healthIndicator.className = 'stream-health-indicator';
            participantContainer.appendChild(healthIndicator);

            // Add name overlay
            const nameOverlay = document.createElement('div');
            nameOverlay.className = 'participant-name';
            nameOverlay.textContent = `${userInfo.username} üîà`;
            participantContainer.appendChild(nameOverlay);
        }

        // Add the media element to the container
        if (track.kind === 'video') {
            const videoElement = document.createElement('video');
            videoElement.autoplay = true;
            videoElement.playsInline = true;
            
            videoElement.setAttribute('data-session-id', track.sessionId);
            videoElement.setAttribute('data-track-id', track.id);
            videoElement.setAttribute('data-track-name', track.trackName);
            videoElement.setAttribute('data-mid', track.mid);
            videoElement.setAttribute('data-track-source', track.source);
            
            videoElement.srcObject = new MediaStream([track]);
            participantContainer.appendChild(videoElement);
        } else if (track.kind === 'audio') {
            const audioElement = document.createElement('audio');
            audioElement.autoplay = true;
            audioElement.controls = true;
            audioElement.style.display = 'none';
            
            audioElement.setAttribute('data-session-id', track.sessionId);
            audioElement.setAttribute('data-track-id', track.id);
            audioElement.setAttribute('data-track-name', track.trackName);
            audioElement.setAttribute('data-mid', track.mid);
            
            audioElement.srcObject = new MediaStream([track]);
            participantContainer.appendChild(audioElement); // Add to participant container instead
        }
    });

    // ===== 4b) Handle Track Unpublished Events =====
    calls.onRemoteTrackUnpublished((sessionId, trackName) => {
        console.log('Track unpublished:', { sessionId, trackName });
        
        // Update participant list when tracks are unpublished
        updateParticipantList();
        
        // Find and remove the media element
        let mediaElement = document.querySelector(`[data-session-id="${sessionId}"][data-track-name="${trackName}"]`);
        
        if (!mediaElement) {
            console.warn('Could not find media element to remove:', { sessionId, trackName });
            return;
        }

        console.log('Found and removing track element:', mediaElement);
        if (mediaElement.srcObject) {
            mediaElement.srcObject.getTracks().forEach(track => track.stop());
        }
        mediaElement.remove();
        
        // Check if participant container is empty (no video/audio elements)
        const participantContainer = document.querySelector(`[data-participant-id="${sessionId}"]`);
        if (participantContainer) {
            const hasMediaElements = participantContainer.querySelector('video, audio');
            if (!hasMediaElements) {
                console.log('Removing empty participant container:', sessionId);
                participantContainer.remove();
            }
        }
    });

    // ===== 5) Data Channel Callbacks =====
    calls.onDataMessage((msg) => {
        console.log('onDataMessage', msg);
        const p = document.createElement('p');
        p.textContent = 'Data Channel Received: ' + JSON.stringify(msg);
        dataChannelMessages.appendChild(p);
    });

    // ===== 6) Participants =====
    calls.onParticipantJoined(async (participant) => {
        console.log('Participant joined:', participant);
        
        // Add a small delay to ensure all backend state is updated
        setTimeout(async () => {
            await updateParticipantList();
            await updateRoomList();
        }, 100);
    });

    calls.onParticipantLeft(async (sessionId) => {
        console.log('Participant left:', sessionId);
        
        // Remove participant's container
        const container = document.querySelector(`.participant-container[data-participant-id="${sessionId}"]`);
        if (container) {
            // Stop all tracks in the container
            container.querySelectorAll('video, audio').forEach(media => {
                if (media.srcObject) {
                    media.srcObject.getTracks().forEach(track => track.stop());
                }
            });
            container.remove();
        }
        
        // Also check for any stray audio elements
        document.querySelectorAll(`audio[data-session-id="${sessionId}"]`)
            .forEach(audio => audio.remove());
        
        await updateParticipantList();
    });

    // ===== 7) Button handlers =====
    acquireTokenBtn.addEventListener('click', async () => {
        try {
            const username = window._username || prompt('Enter username:');
            if (!username) return;
            window._username = username;

            const response = await fetch('/auth/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username })
            });
            const { token } = await response.json();
            
            // Set the token in the library
            calls.setToken(token);
            
            // Update room list after authentication
            await updateRoomList();

            setupLocalPreview();

            acquireTokenBtn.textContent = 'Authenticated ‚úì';
            acquireTokenBtn.disabled = true;
        } catch (err) {
            console.error('Auth error:', err);
            alert('Auth error: ' + err.message);
        }
    });

    createRoomBtn.addEventListener('click', async () => {
        try {
            const roomName = prompt('Enter room name:') || 'Unnamed Room';
            const room = await calls.createRoom({
                name: roomName,
                metadata: {
                    createdBy: window._username
                }
            });
            console.log('Created room:', room, room.roomId);

            history.replaceState(null, '', `?room_id=${encodeURIComponent(room.roomId)}`);
            
            joinRoomBtn.click();
        } catch (err) {
            console.error('Error creating/joining room:', err);
            alert('Error: ' + err.message);
        }
    });

    async function joinRoomById(id) {
        previewMediaBtn.click();

        try {
            // Set default quality before joining
            calls.setMediaQuality('medium_4x3_sm');

            await calls.joinRoom(id, { username: _username });
            console.log('Joined room:', id);

            // Get session ID after joining
            const sessionId = calls.sessionId;
            console.log('Session ID:', sessionId);

            // Set the session ID on our pre-existing local container
            const localContainer = document.querySelector('.participant-container[data-local="true"]');
            if (localContainer) {
                localContainer.setAttribute('data-participant-id', sessionId);
            }

            // Update participant list & room list after joining
            await updateParticipantList();
            await updateRoomList();

            history.replaceState(null, '', `?room_id=${encodeURIComponent(id)}`);

            // Start stats monitoring
            calls.startStatsMonitoring(1000);
        } catch (err) {
            console.error('Error joining room:', err);
            alert('Error joining room: ' + err.message);
        }
    }
    window.joinRoomById = joinRoomById;

    joinRoomBtn.addEventListener('click', async () => {
        if (!window._username) return alert('Acquire token first.');

        let searchRoomId = (location.search.split('room_id=')[1]).split('&')[0];
        if (!window._roomId && searchRoomId) window._roomId = searchRoomId;

        if (!window._roomId) window._roomId = prompt('Enter Room ID to join:');
        if (!_roomId) return;

        await joinRoomById(_roomId);
    });

    leaveRoomBtn.addEventListener('click', async () => {
        await calls.unpublishAllTracks();
        await calls.leaveRoom();
        
        // Clean up all remote participant containers
        document.querySelectorAll('.participant-container:not([data-local="true"])')
            .forEach(container => container.remove());
        
        // Clean up remote audio elements that might be outside containers
        document.querySelectorAll('#videos audio').forEach(audio => audio.remove());
        
        // Clear the participant list when we leave
        participantList.innerHTML = '';
        
        // Update room list after leaving
        await updateRoomList();
        
        alert('Left the room.');
        
        // Clean up stats monitoring
        calls.stopStatsMonitoring();
    });

    toggleVideoBtn.addEventListener('click', async () => {
        const videoTrack = localVideo.srcObject?.getVideoTracks()[0];
        if (videoTrack) {
            const isEnabled = videoTrack.enabled;
            videoTrack.enabled = !isEnabled;
            try {
                await calls.toggleMedia({ video: !isEnabled, audio: null });
                toggleVideoBtn.textContent = isEnabled ? 'Enable Video' : 'Disable Video';
                
                // Get and show updated track status
                const status = await calls.getTrackStatus(videoTrack.id);
                trackStatusDiv.innerHTML = `<div>Video track ${videoTrack.id}: ${status}</div>`;
            } catch (err) {
                console.error('Error toggling video:', err);
                alert('Error: ' + err.message);
            }
        }
    });

    toggleAudioBtn.addEventListener('click', () => {
        const audioTrack = localVideo.srcObject?.getAudioTracks()[0];
        if (audioTrack) {
            const isEnabled = audioTrack.enabled;
            audioTrack.enabled = !isEnabled;
            calls.toggleMedia({ audio: !isEnabled, video: null });
            toggleAudioBtn.textContent = isEnabled ? 'Enable Audio' : 'Disable Audio';
        }
    });

    shareScreenBtn.addEventListener('click', async () => {
        try {
            await calls.shareScreen();
            alert('Screen sharing started.');
        } catch (err) {
            alert('Error sharing screen: ' + err.message);
        }
    });

    // ===== 8) Sending Data =====
    sendDataBtn.addEventListener('click', async () => {
        const content = prompt('Enter message:');
        if (!content) return;

        // We'll send everything on our "chat" channel
        // Make sure we've published it already (see joinRoom code above).
        // Then we can do:
        const message = { content, fromUser: calls.userId };

        calls.sendDataToAll(message);
    });

    document.getElementById('unpublishAll').addEventListener('click', async () => {
        await calls.unpublishAllTracks();
        alert('Unpublished all tracks');
    });

    getSessionStateBtn.addEventListener('click', async () => {
        try {
            const state = await calls.getSessionState();
            trackStatusDiv.innerHTML = '<h3>Track Status:</h3>' + 
                state.tracks.map(track => 
                    `<div>${track.trackName}: ${track.status}</div>`
                ).join('');
        } catch (err) {
            console.error('Error getting session state:', err);
            alert('Error getting session state: ' + err.message);
        }
    });

    forceUnpublishBtn.addEventListener('click', async () => {
        try {
            const userInfo = calls.getUserInfo();
            if (!userInfo?.isModerator) {
                alert('You need moderator privileges to force unpublish tracks.');
                return;
            }

            await calls.unpublishTrack('video', true);
            alert('Video track force unpublished');
        } catch (err) {
            if (err.code === 'NOT_AUTHORIZED') {
                alert('You are not authorized to force unpublish tracks.');
            } else {
                console.error('Error force unpublishing:', err);
                alert('Error: ' + err.message);
            }
        }
    });

    window.onbeforeunload = async function(e) {
        e.preventDefault();
        await calls.unpublishAllTracks();
        return 'Leaving room..';
    }

    async function updateParticipantList() {
        try {
            // Get current user info first
            const currentUser = await calls.getUserInfo();
            const isModerator = currentUser.isModerator;
            
            // Get list of participants in room
            const participants = await calls.listParticipants();
            
            // If we're not in a room, participants will be empty
            if (!participants || participants.length === 0) {
                participantList.innerHTML = '';
                return;
            }
            
            participantList.innerHTML = `
                <div class="participant">
                    <strong>You (${currentUser.username})</strong>
                    ${isModerator ? ' üõ°Ô∏è Moderator' : ''}
                </div>
                ${await Promise.all(participants
                    .filter(p => p.userId !== currentUser.userId)
                    .map(async p => {
                        const userInfo = await calls.getUserInfo(p.userId);
                        return `
                            <div class="participant">
                                <strong>${userInfo.username}</strong>
                                ${isModerator ? `
                                    <button onclick="forceUnpublishParticipant('${p.sessionId}')">
                                        Force Unpublish
                                    </button>
                                ` : ''}
                            </div>
                        `;
                    })
                ).then(items => items.join(''))}
            `;
        } catch (err) {
            console.error('Error updating participant list:', err);
            // Clear the list if there's an error (likely means we're not in a room)
            participantList.innerHTML = '';
        }
    }

    async function forceUnpublishParticipant(sessionId) {
        try {
            const userInfo = await calls.getUserInfo();
            if (!userInfo.isModerator) {
                alert('Only moderators can force unpublish tracks');
                return;
            }

            // In a real app, you might want to specify which track to unpublish
            await calls.unpublishTrack('video', true, sessionId);
            alert('Forced track unpublish successful');
        } catch (err) {
            console.error('Error force unpublishing:', err);
            alert('Error: ' + err.message);
        }
    }
    window.forceUnpublishParticipant = forceUnpublishParticipant;

    const setupLocalPreview = async () => {
        try {
            const previewStream = await calls.previewMedia({
                audioDeviceId: audioInputSelect.value,
                videoDeviceId: videoInputSelect.value
            }, localVideo);
            console.log('Preview successful.');
        } catch (err) {
            alert('Error previewing media: ' + err.message);
        }
        
        try {
            const userInfo = await calls.getUserInfo();
            console.log('User info:', userInfo);

            const localContainer = document.querySelector('.participant-container[data-local="true"]');
            localContainer.setAttribute('data-participant-id', userInfo.userId);
            
            // Add name overlay
            const nameOverlay = document.querySelector('.participant-container[data-local="true"] .participant-name');
            nameOverlay.textContent = `${userInfo.username} (you) üîà`;
        } catch (err) {
            console.error('Error setting up local preview:', err);
        }
    };

    function updateAudioStatus(sessionId, enabled = true) {
        const nameOverlay = document.querySelector(`[data-participant-id="${sessionId}"] .participant-name`);
        if (nameOverlay) {
            // Clean up the name by removing status icons
            const baseName = nameOverlay.textContent
                .replace(/ üîà| üîá/g, '')
                .replace(/ \(you\)/g, '');
            
            // Add back (you) if it's the local user
            const isLocal = sessionId === calls.sessionId;
            nameOverlay.textContent = `${baseName}${isLocal ? ' (you)' : ''} ${enabled ? 'üîà' : 'üîá'}`;
            console.log('Updated audio status:', { sessionId, enabled }, nameOverlay.textContent);
        } else {
            console.log('No name overlay found for session:', sessionId);
        }
    }

    // Use specific handlers for most cases
    calls.onTrackStatusChanged(payload => {
        const { sessionId, enabled, kind } = payload;
        console.log('onTrackStatusChanged kind', kind);
        if (kind === 'audio') {
            updateAudioStatus(sessionId, enabled);
        }
    });

    // Use generic handler for debugging or custom handling
    calls.onWebSocketMessage(msg => {
        console.log('WebSocket message received (generic):', msg);
    });

    // Add connection status monitoring
    function updateConnectionStatus() {
        const status = document.getElementById('connectionStatus');
        if (!window.calls?.ws) {
            status.textContent = '‚ö†Ô∏è No WebSocket';
            status.style.color = 'red';
            return;
        }

        switch (window.calls.ws.readyState) {
            case WebSocket.CONNECTING:
                status.textContent = 'üîÑ Connecting...';
                status.style.color = 'orange';
                break;
            case WebSocket.OPEN:
                status.textContent = 'üü¢ Connected';
                status.style.color = 'green';
                break;
            case WebSocket.CLOSING:
                status.textContent = 'üîÑ Closing...';
                status.style.color = 'orange';
                break;
            case WebSocket.CLOSED:
                status.textContent = 'üî¥ Disconnected';
                status.style.color = 'red';
                break;
        }
    }

    // Update status every second
    setInterval(updateConnectionStatus, 1000);

    // Add room list UI updates
    async function updateRoomList() {
        const roomList = document.getElementById('roomList');
        const rooms = await calls.listRooms();
        
        roomList.innerHTML = rooms.map(room => `
            <div class="room-item">
                <div class="room-info">
                    <div class="room-name">${room.name || 'Unnamed Room'}</div>
                    <div class="room-metadata">
                        Created by: ${room.metadata?.createdBy || 'Unknown'}
                        ¬∑ ${room.participantCount} participant(s)
                    </div>
                </div>
                <div class="room-actions">
                    <button onclick="joinRoomById('${room.roomId}')">Join</button>
                </div>
            </div>
        `).join('');
    }

    // Add metadata update handler
    calls.onRoomMetadataUpdated(async (payload) => {
        console.log('Room metadata updated:', payload);
        await updateRoomList();  // Refresh room list
    });

    // Quality controls
    async function setQuality(preset) {
        try {
            await calls.setMediaQuality(preset);
            console.log(`Set quality to ${preset}`);
        } catch (error) {
            console.error('Error setting quality:', error);
        }
    }
    window.setQuality = setQuality;

    // Connection health monitoring
    const uploadHealth = document.getElementById('uploadHealth');
    const downloadHealth = document.getElementById('downloadHealth');
    const bitrateStats = document.getElementById('bitrateStats');
    const qualityLimitation = document.getElementById('qualityLimitation');
    const packetLoss = document.getElementById('packetLoss');
    const roundTrip = document.getElementById('roundTrip');

    calls.onConnectionStats((stats, streamStats) => {
        // Format bitrates to Mbps/Kbps
        const formatBitrate = (bits) => {
            if (bits > 1000000) {
                return `${(bits / 1000000).toFixed(2)} Mbps`;
            }
            return `${(bits / 1000).toFixed(0)} Kbps`;
        };

        // Update bitrates
        const outBitrate = formatBitrate(stats.outbound.bitrate);
        const inBitrate = formatBitrate(stats.inbound.bitrate);
        bitrateStats.textContent = `‚Üë${outBitrate} ‚Üì${inBitrate}`;

        // Update quality limitation
        const limitation = stats.outbound.qualityLimitation;
        qualityLimitation.textContent = limitation.charAt(0).toUpperCase() + limitation.slice(1);
        qualityLimitation.style.color = limitation === 'none' ? '#4CAF50' : '#FFA726';

        // Update packet loss
        const outLoss = stats.outbound.packetLoss.toFixed(1);
        const inLoss = stats.inbound.packetLoss.toFixed(1);
        packetLoss.textContent = `‚Üë${outLoss}% ‚Üì${inLoss}%`;
        packetLoss.style.color = Math.max(stats.outbound.packetLoss, stats.inbound.packetLoss) > 5 
            ? '#F44336' : '#4CAF50';

        // Update round trip time
        const rtt = (stats.connection.roundTripTime * 1000).toFixed(0);
        roundTrip.textContent = `${rtt}ms`;
        roundTrip.style.color = rtt > 200 ? '#F44336' : rtt > 100 ? '#FFA726' : '#4CAF50';

        // Update overall health indicators
        const getHealthStatus = (stats) => {
            if (stats.packetLoss > 10 || stats.qualityLimitation !== 'none') return 'üî¥ Poor';
            if (stats.packetLoss > 5) return 'üü° Fair';
            return 'üü¢ Good';
        };

        uploadHealth.textContent = getHealthStatus(stats.outbound);
        downloadHealth.textContent = getHealthStatus({
            packetLoss: stats.inbound.packetLoss,
            qualityLimitation: 'none'
        });

        // Update individual stream health indicators
        if (streamStats) {  // Add null check
            streamStats.forEach(streamStat => {
                const container = document.querySelector(`.participant-container[data-participant-id="${streamStat.sessionId}"]`);
                const indicator = container?.querySelector('.stream-health-indicator');
                if (!indicator) return;

                // Remove existing health classes
                indicator.classList.remove('stream-health-good', 'stream-health-fair', 'stream-health-poor');

                // Determine health status
                let healthClass;
                if (streamStat.packetLoss > 10 || streamStat.qualityLimitation !== 'none') {
                    healthClass = 'stream-health-poor';
                } else if (streamStat.packetLoss > 5) {
                    healthClass = 'stream-health-fair';
                } else {
                    healthClass = 'stream-health-good';
                }

                indicator.classList.add(healthClass);
            });
        }
    });
</script>
</body>
</html>

